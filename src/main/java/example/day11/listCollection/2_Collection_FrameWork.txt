> * 인터페이스 : 동일한 목적 하의 서로 다른 기능(Override)을 수행하기 위한 통합
> * 구현(객)체 : 해당 인터페이스를 구현(implements)한 클래스로 객체 생성
> Collection FrameWork
    > 컬렉션(수집), 프레임워크(미리 만들어진 틀)
    > 자료를 수집하는 방법을 미리 만들어 둔 인터페이스 /
    > 복잡한 자료구조를 제공받는다.
> Collection
    > 1. List 인터페이스
        > 공통점 : 저장된 순서(인덱스)를 이용한 데이터 관리, 데이터 중복 허용
        > 1) ArrayList 클래스
            > 객체 선언 방법
            List<제네릭 타입> 변수명 = new ArrayList<>();
            ArrayList<제네릭 타입> 변수명 = new ArrayList<>();

            > 제네릭 타입 : 리스트 객체에 저장할 요소들의 타입
            > 자주 사용되는 메소드
                > [1] .add(요소)               : 리스트 내 요소 추가
                > [2] .set(인덱스, 요소)        : 리스트 내 특정 인덱스에 요소 변경
                > [3] .size()                 : 리스트의 요소 갯수 반환
                > [4] .get(인덱스)             : 리스트 내 특정 인덱스의 요소 값 반환
                > [5] .contains("값" or 객체)  : 리스트 내 특정 값 또는 객체를 검색하여 존재하면 true 없으면 false 반환
                > [6] .indexOf("값" or 객체)   : 리스트 내 특정 값 또는 객체를 검색하여 존재하면 인덱스 없으면 -1 반환
                > [7] .remove(인덱스 or 객체)   : 리스트 내 특정 인덱스 또는 객체가 존재하면 그 요소 삭제
                > [8] .clear()                : 리스트 내 전체 요소 삭제
                > [9] .isEmpty()              : 리스트 내 요소가 하나도 없다면 true, 1개 이상이면 false
        > 2) Vector 클래스
            > List 인터페이스에 동기화가 추가된 클래스
            > 멀티 thread 구현 시 사용

        > 3) LinkedList 클래스
            > 중간 삽입 / 삭제 사용 시 ArrayList 보다 좋은 성능을 가진다.

    > 2. Set 인터페이스
        > 공통점 : 저장된 순서(인덱스)가 없어서 데이터 중복 허용 X
        > 1) HashSet 클래스
            > 자주 사용되는 메소드
                > [1] .add(요소)              : set 객체 내 요소 추가
                > [2] .size()                : set 객체 내 요소 총 개수
                > [3] .remove(요소)           : set 객체 내 동일한 요소가 있다면 삭제
                > [4] .contains(요소)         : set 객체 내 동일한 요소가 존재하면 true, 없다면 false 반환.
                > [5] .clear()               : set 객체 내 전체 요소 삭제
                > [6] .isEmpty()             : set 객체 내 요소가 하나도 없다면 true, 1개 이상이면 false
                > [7] .iterator()            : 반복자 인터페이스 반환
                > [8] .hashNext()            : 다음 요소가 존재하면 true, 아니면 false 반환
                > [9] .next()                : 다음 요소 호출

            > set 인터페이스가 중복을 제거하는 방법 : 객체의 주소값을 비교해서 동일한 주소값은 저장하지 않는다.
                > 리터럴 제외한 객체들을 중복 제거
                    > 1) hashCode() 재정의
                        > @Override
                              public int hashCode() {
                                  return 중복 비교 기준의 필드
                              }

                    > 2) equals() 재정의
                        > @Override
                              public boolean equals(Object obj) {
                                  if(obj instanceof 클래스명){
                                      클래스명 변수명 = (클래스명) obj;
                                      if(this.중복 비교 기준의 필드 == 변수명.중복 비교 기준의 필드){
                                          return true;
                                      }else{
                                          return false;
                                      }
                                  }
                                  return false;
                              }

    > 3. Map 인터페이스
        > 공통점 : 저장된 순서(인덱스)가 없고, key-value 로 이루어진 한 쌍(엔트리)
        > key : 중복 불가능, value : 중복 가능
        > 1) HashMap 클래스
            > 자주 사용되는 메소드
                > [1] .put(key, value)      : key 와 value 엔트리 추가
                > [2] .size()               : map 객체 내 엔트리 갯수
                > [3] .get(key)             : map 객체 내 key 해당하는 value 반환
                > [4] .remove(key)          : map 객체 내 해당하는 key 가 있다면 그 엔트리를 삭제
                > [5] .clear()              : map 객체 내 전체 엔트리 삭제
                > [6] .isEmpty()            : map 객체 내 엔트리가 존재하지 않으면 true, 하나라도 존재하면 false
                > [7] .keySet()             : map 객체 내 모든 key 값 반환(Set 인터페이스로)
                > [8] .values()             : map 객체 내 모든 value 값 반환 (Collection 인터페이스로)
                > [9] .entrySet()           : map 객체 내 모든 entry 반환(Set (Map.Entry)인터페이스로)